<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="TM Therneau" />


<title>Kinship_Matrix_Code_Details</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Kinship_Matrix_Code_Details</h1>
<h4 class="author">TM Therneau</h4>
<h4 class="date">27 September, 2022</h4>


<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#pedigree-object">Pedigree Object</a></li>
<li><a href="#pedigreelist-object">PedigreeList Object</a></li>
<li><a href="#makekinship">MakeKinship</a></li>
<li><a href="#monozygotic-twins-for-pedigree-object">Monozygotic Twins, for Pedigree object</a></li>
</ul></li>
<li><a href="#older-routines">Older routines</a></li>
</ul>
</div>

<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>The kinship matrix is foundational for random effects models with family data.<br />
For <span class="math inline">\(n\)</span> subjects it is an <span class="math inline">\(n \times n\)</span> matrix whose <span class="math inline">\(ij\)</span> element contains the expected fraction of alleles that would be identical by descent if we sampled one from subject <span class="math inline">\(i\)</span> and another from subject <span class="math inline">\(j\)</span>. Note that the diagonal elements of the matrix will be 0.5 not 1: when we randomly sample twice from the same subject (with replacement) we will get two copies of the gene inherited from the father 1/4 of the time, the maternal copy twice (1/4) or one of each 1/2 the time. The formal definition is <span class="math inline">\(K(i,i) = 1/4 + 1/4 + 1/2 K(m,f)\)</span> where <span class="math inline">\(m\)</span> and <span class="math inline">\(f\)</span> are the father and mother of subject <span class="math inline">\(i\)</span>.</p>
<p>The algorithm used is found in K Lange, , Springer 1997, page 71–72.</p>
<p>The key idea of the recursive algorithm for <span class="math inline">\(K(i,j)\)</span> is to condition on the gene selection for the first index <span class="math inline">\(i\)</span>. Let <span class="math inline">\(m(i)\)</span> and <span class="math inline">\(f(i)\)</span> be the indices of the mother and father of subject <span class="math inline">\(i\)</span> and <span class="math inline">\(g\)</span> be the allele randomly sampled from subject <span class="math inline">\(i\)</span>, which may of either maternal or paternal origin.</p>
<p><span class="math display">\[\begin{align}
  K(i,j) &amp;= P(\mbox{$g$ maternal}) * K(m(i), j) + 
            P(\mbox{$g$ paternal}) * K(f(i), j) \label{recur0} \\
         &amp;= 1/2 K(m(i), j) + 1/2 K(f(i), j)   \label{recur1} \\
  K(i,i) &amp;= 1/2(1 + K(m(i), f(i))) \label{self} 
\end{align}\]</span></p>
<p>The key step in equation  is if <span class="math inline">\(g\)</span> has a maternal origin, then it is a random selection from the two maternal genes, and its IBD state with respect to subject <span class="math inline">\(j\)</span> is that of a random selection from m(i) to a random selection from <span class="math inline">\(j\)</span>. This is precisely the definition of <span class="math inline">\(K(m(i), j)\)</span>. The recursion does not work for <span class="math inline">\(K(i,i)\)</span> in equation  since once we select a maternal gene the second choice from <span class="math inline">\(j\)</span> cannot use a different maternal gene.</p>
<p>For the recurrence algorithm to work properly we need to compute the values of <span class="math inline">\(K\)</span> for any parent before the calculations for their children. Pedigree founders (those with no parents) are assumed to be unassociated, so for these subjects we have <span class="math display">\[\begin{align*}
  K(i,i) &amp;= 1/2
  K(i,j) &amp;=0 \; i\ne j
\end{align*}\]</span></p>
<p>The final formula slightly different for the <span class="math inline">\(X\)</span> chromosome. Equation  still holds, but for males the probability that a selected <span class="math inline">\(X\)</span> chromosome is maternal is 1, so when <span class="math inline">\(i\)</span> a male the recurrence formula becomes <span class="math inline">\(K(i,j) = K(m(i),j)\)</span>.<br />
For females it is unchanged. All males will have <span class="math inline">\(K(i,i) = 1\)</span> for the <span class="math inline">\(X\)</span> chromosome.</p>
In order to have already-defined terms on the right hand side of the recurrence formula for each element, subjects need to be processed in the following order

<p>The kindepth routine assigns a plotting depth to each subject in such a way that parents are always above children.<br />
For each depth we need to do the compuations of formula  twice. The first time it will get the relationship between each subject and prior generations correct, the second will correctly compute the values between subjects on the same level. The computations within any stage of the above list can be vectorized, but not those between stages.</p>
<p>Let [[indx]] be the index of the rows for the generation currently being processed, say generation <span class="math inline">\(g\)</span>.<br />
We add correct computations to the matrix one row at a time; all of the calculations depend only on the prior rows with the exception of the [i,i] element. This approach leads to a for loop containing operations on single rows/columns.</p>
<p>At one point below we use a vectorized version. It looks like the snippet below</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="cf">for</span> (g <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">max</span>(depth)) {</span>
<span id="cb1-2"><a href="#cb1-2"></a>    indx &lt;-<span class="st"> </span><span class="kw">which</span>(depth<span class="op">==</span>g)</span>
<span id="cb1-3"><a href="#cb1-3"></a>    kmat[indx,] &lt;-<span class="st"> </span>(kmat[mother[indx],] <span class="op">+</span><span class="st"> </span>kmat[father[indx], ])<span class="op">/</span><span class="dv">2</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    kmat[,indx] &lt;-<span class="st"> </span>(kmat[,mother[indx]] <span class="op">+</span><span class="st"> </span>kmat[,father[indx],])<span class="op">/</span><span class="dv">2</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="cf">for</span> (j <span class="cf">in</span> indx) kmat[j,j] &lt;-<span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>kmat[mother[j], father[j]])<span class="op">/</span><span class="dv">2</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>}</span></code></pre></div>
<p>The first line computes all the values for a horizontal stripe of the matrix. It will be correct for columns in generations <span class="math inline">\(&lt;g\)</span>, unreliable for generation <span class="math inline">\(g\)</span> with itself because of incomplete parental relationships, and zero for higher generations. The second line does the vertical stripe, and because of the line before it does have the data it needs and so gets all the stripe correct. Except of course for the diagonal elements, for which formula  does not hold. We fill those in last. We know that vectorized calculations are always faster in R and I was excited to figure this out. The unfortunate truth is that for this code it hardly makes a difference, and for the X chromosome calculation leads to impenetrable if-then-else logic.</p>
<p>The program can be called with a pedigree, a pedigree list, or raw data. The first argument is [[id]] instead of the more generic [[x]] for backwards compatability with an older version of the routine. We give founders a fake parent of subject <span class="math inline">\(n+1\)</span> who is not related to anybody (even themself); it avoids some if-then-else constructions.</p>
<p>For S3 method dispatch to work on pedigree and pedigreeList objects, we need to define a kinship(), kinship.default(), kinship.pedigree(), and kinship.pedigreeList(). The default version takes the vectors</p>
<div id="pedigree-object" class="section level2">
<h2>Pedigree Object</h2>
<p>The method for a pedigree object is an almost trivial modification. Since the mother and father are already indexed into the id list it has two lines that are different, those that create mrow and drow. The other change is that now we potentially have information available on monozygotic twins. If there are any such, then when the second twin of a pair is added to the matrix, we need to ensure that the pairs kinship coefficient is set to the self-self value. This can be done after each level is complete, but before children for that level are computed. If there are monozygotic triples, quadruplets, etc. this computation gets more involved.</p>
<p>The total number of monozygotic twins is always small, so it is efficient to fix up all the monzygotic twins at each generation. A variable [[havemz]] is set to TRUE if there are any, and an index array [[mzindex]] is created for matrix subscripting.</p>
</div>
<div id="pedigreelist-object" class="section level2">
<h2>PedigreeList Object</h2>
<p>For the Minnesota Family Cancer Study there are 461 families and 29114 subjects. The raw kinship matrix would be 29114 by 29114 which is over 5 terabytes of memory, something that clearly will not work within S.<br />
The solution is to store the overall matrix as a sparse Matrix object. Each family forms a single block. For this study we have [[n &lt;- table(minnbreast$famid); sum(n*(n+1)/2)]] or 1.07 million entries; assuming that only the lower half of each matrix is stored. The actual size is actually smaller than this, since each family matrix will have zeros in it — founders for instance are not related — and those zeros are also not stored.</p>
<p>The result of each per-family call to kinship will be a symmetric matrix. We first turn each of these into a dsCMatrix object, a sparse symmetric form. The [[bdiag]] function is then used to paste all of these individual sparse matrices into a single large matrix.</p>
<p>Why do we note use [[(i in famlist)]] below? A numeric subscript of [[[9]]] %’ selects the ninth family, not the family labeled as 9, so a numeric family id would not act as we wished. If all of the subject ids are unique, across all families, the final matrix is labeled with the subject id, otherwise it is labeled with family/subject.</p>
</div>
<div id="makekinship" class="section level2">
<h2>MakeKinship</h2>
<p>The older [<a href="#makekinship">makekinship</a>] function, from before the creation of pedigreeList objects, accepts the raw identifier data, along with a special family code for unrelated subjects, as produced by the [[makefamid]] function. All the unrelated subjects are put at the front of the kinship matrix in this case rather than within the family. Because unrelateds get put into a fake family, we cannot create a rational family/subject identifier; the id must be unique across families. We include a copy of the routine for backwards compatability, but do not anticipate any new usage of it. Like most routines, this starts out with a collection of error checks.</p>
</div>
<div id="monozygotic-twins-for-pedigree-object" class="section level2">
<h2>Monozygotic Twins, for Pedigree object</h2>
Return now to the question of monzygotic sets, used specifically in the kinship for pedigree objects. Consider the following rather difficult example:

<p>Subjects 1, 2, 3, and 7 form a monozygotic quadruple, 5/6 and 9/10 are monzygotic pairs.<br />
First create a vector  which contains for each subject the lowest index of a monozygotic twin for that subject.<br />
For non-twins it can have any value.<br />
For this example that vector is set to 1 for subjects 1, 2, 3, and 7, to 5 for 5 and 6, and to 9 for 9 and 10. Creating this requires a short while loop. Once this is in hand we can identify the sets.</p>
<p>Next make a matrix that has a row for every possible pair. Finally, remove the rows that are identical. The result is a set of all pairs of observations in the matrix that correspond to monozygotic pairs.</p>
</div>
</div>
<div id="older-routines" class="section level1">
<h1>Older routines</h1>
<p>For testing purposes we have a version of the kinship function prior to addition of the chrtype argument.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>oldkinship &lt;-<span class="st"> </span><span class="cf">function</span>(id, ...) {</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="kw">UseMethod</span>(<span class="st">&#39;oldkinship&#39;</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a>    }</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a>oldkinship.default &lt;-<span class="st"> </span><span class="cf">function</span>(id, dadid, momid, ...) {</span>
<span id="cb2-6"><a href="#cb2-6"></a>    n &lt;-<span class="st"> </span><span class="kw">length</span>(id)</span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="cf">if</span> (n<span class="op">==</span><span class="dv">1</span>) </span>
<span id="cb2-8"><a href="#cb2-8"></a>        <span class="kw">return</span>(<span class="kw">matrix</span>(.<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">1</span>, <span class="dt">dimnames=</span><span class="kw">list</span>(id, id)))</span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="cf">if</span> (<span class="kw">any</span>(<span class="kw">duplicated</span>(id))) <span class="kw">stop</span>(<span class="st">&quot;All id values must be unique&quot;</span>)</span>
<span id="cb2-10"><a href="#cb2-10"></a>    kmat &lt;-<span class="st"> </span><span class="kw">diag</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="op">/</span><span class="dv">2</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    kmat[n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>]    &lt;-<span class="st"> </span><span class="dv">0</span> </span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a>    pdepth &lt;-<span class="st"> </span><span class="kw">kindepth</span>(id, dadid, momid)</span>
<span id="cb2-14"><a href="#cb2-14"></a>    mrow &lt;-<span class="st"> </span><span class="kw">match</span>(momid, id, <span class="dt">nomatch=</span>n<span class="op">+</span><span class="dv">1</span>) <span class="co">#row number of the mother</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>    drow &lt;-<span class="st"> </span><span class="kw">match</span>(dadid, id, <span class="dt">nomatch=</span>n<span class="op">+</span><span class="dv">1</span>) <span class="co">#row number of the dad </span></span>
<span id="cb2-16"><a href="#cb2-16"></a></span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="cf">for</span> (depth <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">max</span>(pdepth)) {</span>
<span id="cb2-18"><a href="#cb2-18"></a>        indx &lt;-<span class="st"> </span>(<span class="dv">1</span><span class="op">:</span>n)[pdepth<span class="op">==</span>depth]</span>
<span id="cb2-19"><a href="#cb2-19"></a>        <span class="cf">for</span> (i <span class="cf">in</span> indx) {</span>
<span id="cb2-20"><a href="#cb2-20"></a>            mom &lt;-<span class="st"> </span>mrow[i]</span>
<span id="cb2-21"><a href="#cb2-21"></a>            dad &lt;-<span class="st"> </span>drow[i]</span>
<span id="cb2-22"><a href="#cb2-22"></a>            kmat[i,]  &lt;-<span class="st"> </span>kmat[,i] &lt;-<span class="st"> </span>(kmat[mom,] <span class="op">+</span><span class="st"> </span>kmat[dad,])<span class="op">/</span><span class="dv">2</span></span>
<span id="cb2-23"><a href="#cb2-23"></a>            kmat[i,i] &lt;-<span class="st"> </span>(<span class="dv">1</span><span class="op">+</span><span class="st"> </span>kmat[mom,dad])<span class="op">/</span><span class="dv">2</span></span>
<span id="cb2-24"><a href="#cb2-24"></a>            }</span>
<span id="cb2-25"><a href="#cb2-25"></a>        }</span>
<span id="cb2-26"><a href="#cb2-26"></a>    </span>
<span id="cb2-27"><a href="#cb2-27"></a>    kmat &lt;-<span class="st"> </span>kmat[<span class="dv">1</span><span class="op">:</span>n,<span class="dv">1</span><span class="op">:</span>n]</span>
<span id="cb2-28"><a href="#cb2-28"></a>    <span class="kw">dimnames</span>(kmat) &lt;-<span class="st"> </span><span class="kw">list</span>(id, id)</span>
<span id="cb2-29"><a href="#cb2-29"></a>    kmat</span>
<span id="cb2-30"><a href="#cb2-30"></a>    }</span>
<span id="cb2-31"><a href="#cb2-31"></a></span>
<span id="cb2-32"><a href="#cb2-32"></a>oldkinship.pedigree &lt;-<span class="st"> </span><span class="cf">function</span>(id, ...) {</span>
<span id="cb2-33"><a href="#cb2-33"></a>    n &lt;-<span class="st"> </span><span class="kw">length</span>(id<span class="op">$</span>id)</span>
<span id="cb2-34"><a href="#cb2-34"></a>    <span class="cf">if</span> (n<span class="op">==</span><span class="dv">1</span>) </span>
<span id="cb2-35"><a href="#cb2-35"></a>        <span class="kw">return</span>(<span class="kw">matrix</span>(.<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">1</span>, <span class="dt">dimnames=</span><span class="kw">list</span>(id<span class="op">$</span>id, id<span class="op">$</span>id)))</span>
<span id="cb2-36"><a href="#cb2-36"></a>    <span class="cf">if</span> (<span class="kw">any</span>(<span class="kw">duplicated</span>(id<span class="op">$</span>id))) <span class="kw">stop</span>(<span class="st">&quot;All id values must be unique&quot;</span>)</span>
<span id="cb2-37"><a href="#cb2-37"></a>    kmat &lt;-<span class="st"> </span><span class="kw">diag</span>(n<span class="op">+</span><span class="dv">1</span>) <span class="op">/</span><span class="dv">2</span></span>
<span id="cb2-38"><a href="#cb2-38"></a>    kmat[n<span class="op">+</span><span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>]    &lt;-<span class="st"> </span><span class="dv">0</span> </span>
<span id="cb2-39"><a href="#cb2-39"></a></span>
<span id="cb2-40"><a href="#cb2-40"></a>    pdepth &lt;-<span class="st"> </span><span class="kw">kindepth</span>(id)</span>
<span id="cb2-41"><a href="#cb2-41"></a>    mrow &lt;-<span class="st"> </span><span class="kw">ifelse</span>(id<span class="op">$</span>mindex <span class="op">==</span><span class="dv">0</span>, n<span class="op">+</span><span class="dv">1</span>, id<span class="op">$</span>mindex)</span>
<span id="cb2-42"><a href="#cb2-42"></a>    drow &lt;-<span class="st"> </span><span class="kw">ifelse</span>(id<span class="op">$</span>findex <span class="op">==</span><span class="dv">0</span>, n<span class="op">+</span><span class="dv">1</span>, id<span class="op">$</span>findex)</span>
<span id="cb2-43"><a href="#cb2-43"></a></span>
<span id="cb2-44"><a href="#cb2-44"></a>    <span class="co"># Are there any MZ twins to worry about?</span></span>
<span id="cb2-45"><a href="#cb2-45"></a>    <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(id<span class="op">$</span>relation) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">any</span>(id<span class="op">$</span>relation<span class="op">$</span>code<span class="op">==</span><span class="st">&quot;MZ twin&quot;</span>)) {</span>
<span id="cb2-46"><a href="#cb2-46"></a>        havemz &lt;-<span class="st"> </span><span class="ot">TRUE</span></span>
<span id="cb2-47"><a href="#cb2-47"></a>        temp &lt;-<span class="st"> </span><span class="kw">which</span>(id<span class="op">$</span>relation<span class="op">$</span>code<span class="op">==</span><span class="st">&quot;MZ twin&quot;</span>)</span>
<span id="cb2-48"><a href="#cb2-48"></a>        <span class="co">## drop=FALSE added in case only one MZ twin set</span></span>
<span id="cb2-49"><a href="#cb2-49"></a>        mzmat &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(id<span class="op">$</span>relation[,<span class="kw">c</span>(<span class="st">&quot;indx1&quot;</span>, <span class="st">&quot;indx2&quot;</span>)])[temp,,drop=<span class="ot">FALSE</span>]</span>
<span id="cb2-50"><a href="#cb2-50"></a></span>
<span id="cb2-51"><a href="#cb2-51"></a>        <span class="co"># any triples, quads, etc?</span></span>
<span id="cb2-52"><a href="#cb2-52"></a>        <span class="cf">if</span> (<span class="kw">any</span>(<span class="kw">table</span>(mzmat) <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)) { <span class="co">#yes there are</span></span>
<span id="cb2-53"><a href="#cb2-53"></a>            <span class="co"># each group id will be min(member id)</span></span>
<span id="cb2-54"><a href="#cb2-54"></a>            mzgrp &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">max</span>(mzmat)  <span class="co">#each person a group</span></span>
<span id="cb2-55"><a href="#cb2-55"></a>            indx &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">unique</span>(<span class="kw">as.vector</span>(mzmat)))</span>
<span id="cb2-56"><a href="#cb2-56"></a>            <span class="co"># The loop below will take k-1 iterations for a set labeled as</span></span>
<span id="cb2-57"><a href="#cb2-57"></a>            <span class="co">#   1:2, 2:3, ...(k-1):k;  this is the worst case.</span></span>
<span id="cb2-58"><a href="#cb2-58"></a>            <span class="cf">while</span>(<span class="dv">1</span>) {</span>
<span id="cb2-59"><a href="#cb2-59"></a>                z1 &lt;-<span class="st"> </span>mzgrp[mzmat[,<span class="dv">1</span>]]</span>
<span id="cb2-60"><a href="#cb2-60"></a>                z2 &lt;-<span class="st"> </span>mzgrp[mzmat[,<span class="dv">2</span>]]</span>
<span id="cb2-61"><a href="#cb2-61"></a>                <span class="cf">if</span> (<span class="kw">all</span>(z1 <span class="op">==</span><span class="st"> </span>z2)) <span class="cf">break</span></span>
<span id="cb2-62"><a href="#cb2-62"></a>                mzgrp[indx] &lt;-<span class="st"> </span><span class="kw">tapply</span>(<span class="kw">c</span>(z1, z1, z2, z2), <span class="kw">c</span>(mzmat,mzmat), min)</span>
<span id="cb2-63"><a href="#cb2-63"></a>            }</span>
<span id="cb2-64"><a href="#cb2-64"></a>            <span class="co"># Now mzgrp = min person id for each person in a set</span></span>
<span id="cb2-65"><a href="#cb2-65"></a>            matlist &lt;-<span class="st"> </span><span class="kw">tapply</span>(mzmat, mzgrp[mzmat], <span class="cf">function</span>(x) {</span>
<span id="cb2-66"><a href="#cb2-66"></a>                x &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">unique</span>(x))</span>
<span id="cb2-67"><a href="#cb2-67"></a>                temp &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rep</span>(x, <span class="dt">each=</span><span class="kw">length</span>(x)), <span class="kw">rep</span>(x, <span class="kw">length</span>(x)))</span>
<span id="cb2-68"><a href="#cb2-68"></a>                temp[temp[,<span class="dv">1</span>] <span class="op">!=</span><span class="st"> </span>temp[,<span class="dv">2</span>],]</span>
<span id="cb2-69"><a href="#cb2-69"></a>                })</span>
<span id="cb2-70"><a href="#cb2-70"></a>            }</span>
<span id="cb2-71"><a href="#cb2-71"></a>        <span class="cf">else</span> {  <span class="co">#no triples, easier case</span></span>
<span id="cb2-72"><a href="#cb2-72"></a>            matlist &lt;-<span class="st"> </span><span class="kw">tapply</span>(mzmat, <span class="kw">row</span>(mzmat), <span class="cf">function</span>(x) </span>
<span id="cb2-73"><a href="#cb2-73"></a>                            <span class="kw">matrix</span>(x[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>)],<span class="dv">2</span>), <span class="dt">simplify=</span><span class="ot">FALSE</span>)</span>
<span id="cb2-74"><a href="#cb2-74"></a>            }</span>
<span id="cb2-75"><a href="#cb2-75"></a>        }</span>
<span id="cb2-76"><a href="#cb2-76"></a>    <span class="cf">else</span> havemz &lt;-<span class="st"> </span><span class="ot">FALSE</span></span>
<span id="cb2-77"><a href="#cb2-77"></a></span>
<span id="cb2-78"><a href="#cb2-78"></a>    <span class="cf">for</span> (depth <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">max</span>(pdepth)) {</span>
<span id="cb2-79"><a href="#cb2-79"></a>        indx &lt;-<span class="st"> </span>(<span class="dv">1</span><span class="op">:</span>n)[pdepth<span class="op">==</span>depth]</span>
<span id="cb2-80"><a href="#cb2-80"></a>        <span class="cf">for</span> (i <span class="cf">in</span> indx) {</span>
<span id="cb2-81"><a href="#cb2-81"></a>            mom &lt;-<span class="st"> </span>mrow[i]</span>
<span id="cb2-82"><a href="#cb2-82"></a>            dad &lt;-<span class="st"> </span>drow[i]</span>
<span id="cb2-83"><a href="#cb2-83"></a>            kmat[i,]  &lt;-<span class="st"> </span>kmat[,i] &lt;-<span class="st"> </span>(kmat[mom,] <span class="op">+</span><span class="st"> </span>kmat[dad,])<span class="op">/</span><span class="dv">2</span></span>
<span id="cb2-84"><a href="#cb2-84"></a>            kmat[i,i] &lt;-<span class="st"> </span>(<span class="dv">1</span><span class="op">+</span><span class="st"> </span>kmat[mom,dad])<span class="op">/</span><span class="dv">2</span></span>
<span id="cb2-85"><a href="#cb2-85"></a>            }</span>
<span id="cb2-86"><a href="#cb2-86"></a>        <span class="cf">if</span> (havemz) {</span>
<span id="cb2-87"><a href="#cb2-87"></a>            <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(matlist)) {</span>
<span id="cb2-88"><a href="#cb2-88"></a>                temp &lt;-<span class="st"> </span>matlist[[i]]</span>
<span id="cb2-89"><a href="#cb2-89"></a>                kmat[temp] &lt;-<span class="st"> </span>kmat[temp[<span class="dv">1</span>], temp[<span class="dv">1</span>]]</span>
<span id="cb2-90"><a href="#cb2-90"></a>            }</span>
<span id="cb2-91"><a href="#cb2-91"></a>        }</span>
<span id="cb2-92"><a href="#cb2-92"></a>    }</span>
<span id="cb2-93"><a href="#cb2-93"></a>    </span>
<span id="cb2-94"><a href="#cb2-94"></a>    kmat &lt;-<span class="st"> </span>kmat[<span class="dv">1</span><span class="op">:</span>n,<span class="dv">1</span><span class="op">:</span>n]</span>
<span id="cb2-95"><a href="#cb2-95"></a>    <span class="kw">dimnames</span>(kmat) &lt;-<span class="st"> </span><span class="kw">list</span>(id<span class="op">$</span>id, id<span class="op">$</span>id)</span>
<span id="cb2-96"><a href="#cb2-96"></a>    kmat</span>
<span id="cb2-97"><a href="#cb2-97"></a>}    </span>
<span id="cb2-98"><a href="#cb2-98"></a></span>
<span id="cb2-99"><a href="#cb2-99"></a>oldkinship.pedigreeList &lt;-<span class="st"> </span><span class="cf">function</span>(id, ...) {</span>
<span id="cb2-100"><a href="#cb2-100"></a>    famlist &lt;-<span class="st"> </span><span class="kw">unique</span>(id<span class="op">$</span>famid)</span>
<span id="cb2-101"><a href="#cb2-101"></a>    nfam &lt;-<span class="st"> </span><span class="kw">length</span>(famlist)</span>
<span id="cb2-102"><a href="#cb2-102"></a>    matlist &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nfam)</span>
<span id="cb2-103"><a href="#cb2-103"></a>    idlist  &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, nfam) <span class="co">#the possibly reorderd list of id values</span></span>
<span id="cb2-104"><a href="#cb2-104"></a>   </span>
<span id="cb2-105"><a href="#cb2-105"></a>    <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(famlist)) {</span>
<span id="cb2-106"><a href="#cb2-106"></a>        tped &lt;-<span class="st"> </span>id[i]  <span class="co">#pedigree for this family</span></span>
<span id="cb2-107"><a href="#cb2-107"></a>        temp &lt;-<span class="st"> </span><span class="kw">try</span>(<span class="kw">oldkinship</span>(tped, ...), <span class="dt">silent=</span><span class="ot">TRUE</span>)</span>
<span id="cb2-108"><a href="#cb2-108"></a>        <span class="cf">if</span> (<span class="kw">class</span>(temp)<span class="op">==</span><span class="st">&quot;try-error&quot;</span>) </span>
<span id="cb2-109"><a href="#cb2-109"></a>            <span class="kw">stop</span>(<span class="kw">paste</span>(<span class="st">&quot;In family&quot;</span>, famlist[i], <span class="st">&quot;:&quot;</span>, temp))</span>
<span id="cb2-110"><a href="#cb2-110"></a>        <span class="cf">else</span> matlist[[i]] &lt;-<span class="st"> </span><span class="kw">as</span>(<span class="kw">forceSymmetric</span>(temp), <span class="st">&quot;dsCMatrix&quot;</span>)</span>
<span id="cb2-111"><a href="#cb2-111"></a>        idlist[[i]] &lt;-<span class="st"> </span>tped<span class="op">$</span>id</span>
<span id="cb2-112"><a href="#cb2-112"></a>    }</span>
<span id="cb2-113"><a href="#cb2-113"></a></span>
<span id="cb2-114"><a href="#cb2-114"></a>    result &lt;-<span class="st"> </span><span class="kw">bdiag</span>(matlist)</span>
<span id="cb2-115"><a href="#cb2-115"></a>    <span class="cf">if</span> (<span class="kw">any</span>(<span class="kw">duplicated</span>(id<span class="op">$</span>id))) </span>
<span id="cb2-116"><a href="#cb2-116"></a>        temp &lt;-<span class="kw">paste</span>(<span class="kw">rep</span>(famlist, <span class="kw">sapply</span>(idlist, length)),</span>
<span id="cb2-117"><a href="#cb2-117"></a>                     <span class="kw">unlist</span>(idlist), <span class="dt">sep=</span><span class="st">&#39;/&#39;</span>) </span>
<span id="cb2-118"><a href="#cb2-118"></a>    <span class="cf">else</span> temp &lt;-<span class="st"> </span><span class="kw">unlist</span>(idlist)</span>
<span id="cb2-119"><a href="#cb2-119"></a>        </span>
<span id="cb2-120"><a href="#cb2-120"></a>    <span class="kw">dimnames</span>(result) &lt;-<span class="st"> </span><span class="kw">list</span>(temp, temp)</span>
<span id="cb2-121"><a href="#cb2-121"></a>    result</span>
<span id="cb2-122"><a href="#cb2-122"></a>}</span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
